'''
This module is all about pot interface functions
'''

from interface import db, payload
import simplejson as json
from simplejson.encoder import RawJSON

db_name = "pot.sqlite"
tbl_name = "pot"

def Register(project_name, suffix_query, notif_method, html_template, html_code, js_code_name, custom_js_code, will_expire_in):
    '''
    Add the given information into the Pot DB:
        - Generate url suffixes as Primary Keys from suffix_query
        - js_code_name is the name of preset js payload
        - will_expire_in is an integer minutes that this pot will be deleted in,
            needs to use _Calculate_timestamp to calculate the target timestamp.
    @Return:
        A tuple: (# suffixes needed to register, # registered suffixes)
    '''
    num_of_registered_url_suffixes = 0
    url_suffix_list = _Suffix_query_parse(suffix_query)
    for each_url_suffix in url_suffix_list:
        # Check if each url_suffix exists, if not, then add into the db
        if db.Exist("url_suffix", each_url_suffix, db_name, tbl_name):
            # Do nothing and goto the next url_suffix
            continue
        # Calculate valid_til timestamp
        valid_til = _Calculate_timestamp(int(will_expire_in))
        # Inject custom js code into the html
        html_code = Inject_html(html_code, custom_js_code)
        # Construct and Add the new record into pot database
        data = {
            "project_name"  :   project_name,
            "url_suffix"    :   each_url_suffix,
            "suffix_query"  :   suffix_query,
            "notif_method"  :   notif_method,
            "html_template" :   html_template,
            "html_code"     :   html_code,
            "js_code_name"  :   js_code_name,
            "custom_js_code":   custom_js_code,
            "valid_til"     :   valid_til
        }
        db.Add(data, db_name, tbl_name)
        num_of_registered_url_suffixes += 1
    return (len(url_suffix_list), num_of_registered_url_suffixes)

def Exist_url_suffix(url_suffix):
    '''
    Checks if the given url_suffix (pKey) exists in the pot database
    @Return: True if the url_suffix exists, False otherwise
    '''
    return db.Exist("url_suffix", url_suffix, db_name, tbl_name)

def Delete(suffix_query):
    '''
    Remove url_suffix pots generated by given suffix_query
    @Return:
        A tuple: (# suffixes needed to delete, # deleted suffixes)
    '''
    url_suffix_list = _Suffix_query_parse(suffix_query)
    num_deleted = 0
    for each_url_suffix in url_suffix_list:
        # Skip deletion if the url_suffix does not exist in db.
        if not db.Exist("suffix_query", each_url_suffix, db_name, tbl_name):
            continue
        # Remove the record and Incremenet the counter
        db.Remove("suffix_query", each_url_suffix, db_name, tbl_name)
        num_deleted += 1
    return (len(url_suffix_list), num_deleted)

def _Calculate_timestamp(num_of_minutes):
    '''
    @Return: expire_timestamp = current_timestamp + num_of_minutes
    '''
    import datetime
    current_timestamp = int(datetime.datetime.now().timestamp())
    expire_timestamp = current_timestamp + num_of_minutes * 60
    return expire_timestamp

def _Suffix_query_parse(suffix_syntax):
    '''
    Parses the suffix syntax query into a distinct list of url suffixes
    @Return: A list of all suffixes generated by the given suffix query
    '''
    # Temporarily make url_suffix the same as the suffix query,
    #   need to change later on
    return [suffix_syntax]

def Get_all_pots():
    '''
    @Return: A JSON dict of all pots information.
    '''
    list_of_pots = []
    list_of_pots.extend([
        {
            "id"            :   each_pot["id"],
            "project_name"  :   each_pot["project_name"],
            "url_suffix"    :   each_pot["url_suffix"],
            "suffix_query"  :   each_pot["suffix_query"],
            "notif_method"  :   each_pot["notif_method"],
            "html_template" :   str(each_pot["html_template"]),
            "html_code"     :   str(each_pot["html_code"]),
            "js_code_name"  :   each_pot["js_code_name"],
            "custom_js_code":   each_pot["custom_js_code"],
            "valid_til"     :   each_pot["valid_til"]
        }
        for each_pot in db.Get_all_records(db_name, tbl_name)])
    return json.dumps(list_of_pots)

def Search_pot_by_url_suffix(url_suffix, is_json=False):
    result = db.Search_one_record("url_suffix", url_suffix, db_name, tbl_name)
    if is_json:
        return json.dumps(RawJSON(result))
    return result

def Inject_html(original_html, custom_js_code):
    '''
    @@Return: HTML code with custom js injected
    '''
    # Load the js_code by lookup payload name of the pot from payload library
    if len(custom_js_code) == 0:
        return original_html
    tag = "</script>"
    if "<head>" in original_html:
        tag = "<head>"
    elif "<html>" in original_html:
        tag = "<html>"
    elif "<body>" in original_html:
        tag = "<body>"
    before_html = original_html[:original_html.index(tag)+len(tag)]
    after_html = original_html[original_html.index(tag)+len(tag):]
    injected_html = before_html + "<script>" + custom_js_code + "</script>" + after_html
    return injected_html

def Craft_payload(pot_record):
    '''
    Craft the HTML page given the pot_record (insert payload after <html> tag)
    Future: Encrypt the js payload
    @Return: HTML html_template with the predefined js payload inside
    '''
    original_html = str(pot_record["html_code"])
    # Load the js_code by lookup payload name of the pot from payload library
    js_code_name = pot_record["js_code_name"]
    js_code = payload.Search_payload_by_name(js_code_name)
    if len(js_code) == 0:
        return original_html
    tag = "</script>"
    if "<head>" in original_html:
        tag = "<head>"
    elif "<html>" in original_html:
        tag = "<html>"
    elif "<body>" in original_html:
        tag = "<body>"
    before_html = original_html[:original_html.index(tag)+len(tag)]
    after_html = original_html[original_html.index(tag)+len(tag):]
    crafted_html = before_html + json.dumps(js_code[3]) + after_html
    return crafted_html
